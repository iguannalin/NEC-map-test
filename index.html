<!DOCTYPE html>
<html lang="en">
<head>
  <title>NEC Members Map</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin=""/>
  <!-- Make sure you put this AFTER Leaflet's CSS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
          integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
          crossorigin=""></script>
  <!-- leaflet-search created by Stefano Cudini https://opengeo.tech/stefano-cudini/ -->
  <script src="dist/leaflet-search.min.js"></script>
  <link rel="stylesheet" href="dist/leaflet-search.min.css"/>
</head>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Titillium+Web:ital,wght@0,200;0,300;0,400;0,600;0,700;0,900;1,200;1,300;1,400;1,600;1,700&display=swap');
  body {
    overflow: hidden;
    width: 100%;
    padding: 0;
    margin: 0 auto;
  }
  #map {
    height: 400px;
    border: 2px solid #1b232d;
    font-family: 'Poppins',Helvetica,Arial,Lucida,sans-serif;
  }
  .leaflet-popup {
    max-height: 300px;
    width: 275px;
    overflow: scroll;
  }
  .placeName { text-transform: capitalize; }
  .disclaimer {
    padding: 5px;
    color: navy;
  }
  #filters-header-container {
    padding: 12px 16px;
    border: 2px solid #1b232d;
    margin: -2px 0 -2px;
    background: #f1dc5b;
    color: #1b232d;
    font-family: 'Poppins',Helvetica,Arial,Lucida,sans-serif;
    font-weight: 500;
    font-size: 14px;
    text-transform: lowercase;
    min-height: 50px;
    max-height: 75px;
    overflow-y: scroll;
  }
  #applied-filters {
    margin: 2px 0;
  }
  #optional-showing-filter {
    position: absolute;
    right: 16px;
    top: 425px;
  }
  #filter-label {
    margin: 0 auto;
    text-transform: uppercase;
    font-size: 20px;
    font-weight: 700;
    font-family: 'Titillium Web', Helvetica, Arial, Lucida, sans-serif;
  }
  #filters {
    display: flex;
    justify-content: flex-start;
    align-items: center;
    flex-flow: row wrap;
    overflow: scroll;
    height: 125px;
    border: 2px solid #1b232d;
    padding: 6px 4px;
  }
  .checkbox-container input {
    visibility: hidden;
    position: absolute;
  }
  .checkbox-container label, #button-filter-clearall {
    font-family: 'Poppins',Helvetica,Arial,Lucida,sans-serif;
    font-size: 14px;
    background-color: transparent;
    border: 2px solid #27b99e;
    padding: 4px 10px;
    margin: 4px;
    display: flex;
    text-align: center;
    text-transform: lowercase;
    border-radius: 20px;
    color: #1b232d;
    cursor: pointer;
    box-sizing: border-box;
  }
  .checkbox-container input[type="checkbox"]:checked + label,
  #button-filter-clearall:hover,
  .checkbox-container label:hover {
    color: white;
    background-color: #27b99e;
  }
  #button-filter-clearall {
    border: 2px solid #1b232d;
    text-transform: uppercase;
  }
  .marker { fill: #e07ee0; }
  .marker-icon { fill: #e07ee0; }
  .filter-color-1 { border-color: #e07ee0 !important; }
  .filter-color-2 { border-color: #f76a57 !important; }
  .filter-color-3 { border-color: #fcc949 !important; }
  .filter-color-4 { border-color: #3fc991 !important; }
  .filter-color-5 { border-color: #62b3ef !important; }
</style>
<body>
<div id="container">
  <div id="map"></div>
  <div id="filters-header-container">
    <h3 id="filter-label">Filters</h3>
    <p id="applied-filters"></p>
    <i id="optional-showing-filter"></i>
  </div>
  <div id="filters">
    <div class="checkbox-container">
      <button id="button-filter-clearall" onclick="clearAllFilters()">Clear All</button>
    </div>
  </div>
</div>
<script>
  const alphabet = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
  const filterColors = 5; // available unique theme colors
  let markerCount = 0; // for counting markers on map
  let places = {}; // { "placeName" : { "latitude": 0.00, "longitude": 0.00 } }
  let orgMarkers = {}; // { "orgTitle": { "marker": Marker, "isHidden": "false" } }
  let filters = {} ; // { "Mutual Aid" : [ "Upstream Podcast" ], ... }
  let appliedFilters = []; // [ "Mutual Aid", ... ]
  const showing = document.querySelector("#applied-filters");
  const optionalShowing = document.querySelector("#optional-showing-filter");
  const svgTemplate = `
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" class="marker-icon">
      <path fill-opacity=".25" d="M16 32s1.427-9.585 3.761-12.025c4.595-4.805 8.685-.99 8.685-.99s4.044 3.964-.526 8.743C25.514 30.245 16 32 16 32z"/>
      <path stroke="#000" d="M15.938 32S6 17.938 6 11.938C6 .125 15.938 0 15.938 0S26 .125 26 11.875C26 18.062 15.938 32 15.938 32zM16 6a4 4 0 100 8 4 4 0 000-8z"/>
    </svg>`;

  const markerIcon = L.divIcon({
    html: svgTemplate,
    iconSize: [40, 40],
    iconAnchor: [12, 24],
    popupAnchor: [7, -16],
    className: 'marker-icon'
  });

  // create map
  const map = L.map('map').setView([45, -100], 3);
  L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19,
    attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
  }).addTo(map);

  // add search bar to map
  const layerGroup = new L.LayerGroup();	//layer contain searched elements
  map.addLayer(layerGroup);
  const controlSearch = new L.Control.Search({
    position:'topright',
    layer: layerGroup,
    initial: false,
    zoom: 14,
    marker: { icon: false, animate: true }
  });
  map.addControl( controlSearch );

  function placeOnMap(entry, placeName, locationData) {
    markerCount++;
    const marker = L.marker([locationData.latitude, locationData.longitude], {title: entry["Member Org Name"], riseOnHover: true, icon: markerIcon}).addTo(map);
    let orgMission = "";
    // shorten org mission statement
    if (entry["Organizational mission"]) {
      const max = 200;
      orgMission = entry["Organizational mission"];
      if (orgMission.length > max) orgMission = orgMission.substring(0, max) + "...";
    }
    marker.bindPopup(`
                    <b>${entry["Member Org Name"]}</b>
                    <p class="orgMission">${orgMission}</p>
                    <p>${entry["Region"] ? 'Region: ' + entry["Region"] : ""}</p>
                    <p class="placeName">${placeName}</p>
                    <p>${entry["Website"] ? 'Website: <a href=' + entry["Website"] + '>' + entry["Website"] + '</a>' : ""}</p>
                `);
    orgMarkers[entry["Member Org Name"]] = { marker, isHidden: false };
    layerGroup.addLayer(marker);
  }

  // clear all filters, and show all org markers
  function clearAllFilters() {
    appliedFilters = [];
    showing.innerHTML = "";
    document.querySelectorAll("input[type='checkbox']:checked").forEach((elem) => elem.checked = false);
    Object.keys(orgMarkers).forEach((org) => {
      orgMarkers[org].isHidden = false;
      layerGroup.addLayer(orgMarkers[org].marker);
    });
  }

  // if filter is applied, hide all markers except for the filtered
  function applyFilters(filter, checked) {
    if (checked) appliedFilters.push(filter);  // add filter to list of applied filters
    else appliedFilters.splice(appliedFilters.findIndex((a) => a === filter), 1); // remove from filter if unchecked

    if (showing && appliedFilters) showing.innerHTML = "showing: " + appliedFilters.join(", ");
    else if (showing && !appliedFilters) showing.innerHTML = "";

    Object.keys(orgMarkers).forEach((org) => {
      // return all markers to hidden by default
      if (!orgMarkers[org].isHidden) {
        layerGroup.removeLayer(orgMarkers[org].marker);
        orgMarkers[org].isHidden = true;
      }
      appliedFilters.forEach((filter) => {
        // check if org is in filter group
        if (filters[filter].includes(org)) {
          orgMarkers[org].isHidden = false;
          layerGroup.addLayer(orgMarkers[org].marker);
        }
      });
    });
  }

  function sortOrganizationsByFilters(entry) {
    if (entry["SE models (from 2022 Member Survey 4)"]) {
      entry["SE models (from 2022 Member Survey 4)"].forEach((filter) => {
        if (filters[filter]) { // if filter already exists in list
          filters[filter].push(entry["Member Org Name"]);
        } else { // otherwise create a new entry
          filters[filter] = [entry["Member Org Name"]];
        }
      });
    }
  }

  function shortenString(text, maxLength) {
    return text.length > maxLength ? text.substring(0, maxLength) + "..." : text;
  }

  function createFilterCheckboxes() {
    Object.keys(filters).sort().forEach((filter, index) => {
      const filtersContainer = document.getElementById("filters");
      const container = document.createElement("div");
      container.className = "checkbox-container";
      const input = document.createElement("input");
      const label = document.createElement("label");
      const filterClassName = "filter-" + filter.replace(/[^\p{L}\p{N}]/giu, ''); // convert category into a CSS-friendly class-name
      input.id = `checkbox-${filterClassName}`;
      input.type = "checkbox";
      input.name = filter;
      label.title = filter;
      label.htmlFor = `checkbox-${filterClassName}`;
      label.innerText = shortenString(filter, 20);
      label.addEventListener("mouseenter", () => {
        optionalShowing.innerText += filter;
      });
      label.addEventListener("mouseleave", () => {
        optionalShowing.innerText = "";
      });
      input.addEventListener(("change"), (elem) => {
        applyFilters(elem.target.name, elem.target.checked);
      });
      container.appendChild(input);
      container.appendChild(label);
      filtersContainer.appendChild(container);

      label.classList.add(`filter-color-${(index % filterColors) + 1}`);
      // add filter category to marker CSS classname
      // L.DomUtil.addClass(marker._icon, `filter-color-${alphabet.findIndex((l) => l === filter[0].toUpperCase()) % filterColors + 1}`);
      // L.DomUtil.addClass(marker._icon, "organization-marker");
    });
  }

  function getOffsetLocation(location) { // offset location by a few points just to scatter markers by a little bit
    const latitude = location.latitude + (Math.random() * 0.007 * ((Math.random() > 0.5) ? 1 : -1));
    const longitude = location.longitude + (Math.random() * 0.007 * ((Math.random() > 0.5) ? 1 : -1));
    return {latitude, longitude};
  }

  // get stored geolocation data to save api calls to fetch lat/long coords
  fetch("places.json").then((p) => p.json()).then((d) => {
    places = d;
    // get members data from airtable
    // fetch("scratch.json").then((r) => r.json()).then((data) => {
    fetch("https://nec-airtable.netlify.app/.netlify/functions/api").then((r) => r.json()).then((data) => {
      // info to pass to popup for map marker
      let popupPlaceName = "";
      let popupLocationData = places["international"];

      // go through each entry, and find its lat/long coordinates
      // narrowing from country down to city, being as specific with the location as it can be
      data.forEach((entry) => {
        if (entry["fields"]) entry = entry["fields"];
        if (entry["Country"]) {
          let country = entry["Country"][0].trim().toLowerCase();
          if (country === "united states") country = "united states of america"; // convert for geodb, because geodb calls it the USA but airtable calls it the US
          if (!places[country]) { // if country doesn't already exist in store (places.json)
            fetch(`http://geodb-free-service.wirefreethought.com/v1/geo/countries?namePrefix=${country}&hateoasMode=false&limit=5&offset=0`).then((d) => d.json()).then((r) => {
              if (r && r.data) {
                const place = r.data.find((el) => el.country.toLowerCase() === country);
                if (place) {
                  places[place.country.toLowerCase()] = {
                    latitude: place.latitude,
                    longitude: place.longitude
                  }
                  popupPlaceName = country;
                  popupLocationData = places[place.country.toLowerCase()];
                }
              }
            });
          } else if (places[country]) { // if country already exists in store
            popupPlaceName = country;
            popupLocationData = places[country];
          } else { // if country could not be found in store or on geodb
            popupPlaceName = country;
            popupLocationData = places[country];
            console.info("No country found for " + entry["Member Org Name"]);
          }

          if (country === "united states of america" && entry["State"]) { // in the case where there is a state listed
            const state = entry["State"][0].trim().toLowerCase();
            if (!places[state + "+" + country]) { // if state doesn't already exist in store (places.json)
              // need to first get iso code of state
              fetch(`http://geodb-free-service.wirefreethought.com/v1/geo/countries/US/regions?namePrefix=${state}&hateoasMode=false&limit=5&offset=0`).then((d) => d.json()).then((r) => {
                if (r && r.data) {
                  const place = r.data.find((el) => el.name.toLowerCase() === state);
                  if (place) {
                    // then use iso code to find the largest admin region of that state, and use that as the state geo coords
                    fetch(`http://geodb-free-service.wirefreethought.com/v1/geo/countries/US/regions/${place.isoCode}/places?types=ADM2&hateoasMode=false&limit=5&offset=0&sort=-population`).then((d) => d.json()).then((r) => {
                      if (r.data) {
                        const region = r.data[0];
                        places[state + "+" + country] = {
                          latitude: region.latitude,
                          longitude: region.longitude
                        }
                        popupPlaceName = `${state}, ${country}`;
                        popupLocationData = places[state + "+" + country];
                      }
                    });
                  }
                }
              });
            } else if (places[state + "+" + country]) { // if state already exists in store
              popupPlaceName = `${state}, ${country}`;
              popupLocationData = places[state + "+" + country];
            } else { // if state could not be found in store or on geodb
              popupPlaceName = `${state}, ${country}`;
              popupLocationData = places[country];
              console.info("No state found for " + entry["Member Org Name"]);
            }
          }

          if (entry["City"]) { // in the case where there is a city listed
            const city = entry["City"][0].trim().toLowerCase();
            if (!places[city + "+" + country]) { // if city does not already exist in store
              fetch(`http://geodb-free-service.wirefreethought.com/v1/geo/places?namePrefix=${city}&hateoasMode=false&limit=5&offset=0`).then((d) => d.json()).then((r) => {
                if (r && r.data) {
                  const place = r.data.find((el) =>
                    el.name.toLowerCase() === city &&
                    el.country.toLowerCase() === country
                  );
                  if (place) {
                    places[place.name.toLowerCase() + "+" + place.country.toLowerCase()] = {
                      latitude: place.latitude,
                      longitude: place.longitude
                    }
                    popupPlaceName = `${city}, ${country}`;
                    popupLocationData = places[place.name.toLowerCase() + "+" + place.country.toLowerCase()];
                  }
                }
              });
            } else if (places[city + "+" + country]) { // if city already exists in store
              popupPlaceName = `${city}, ${country}`;
              popupLocationData = places[city + "+" + country];
            } else { // if city could not be found in store or on geodb
              popupPlaceName = `${city}, ${country}`;
              popupLocationData = places[country];
              console.info("No city found for " + entry["Member Org Name"]);
            }
          }
        } else { // if no country listed
          console.info("No country listed for " + entry["Member Org Name"] + "; couldn't place on map");
        }
        placeOnMap(entry, popupPlaceName.replace("united states of america", "united states"), getOffsetLocation(popupLocationData));
        sortOrganizationsByFilters(entry); // marker can only be styled by category after it is placed on map / rendered
      });
      createFilterCheckboxes();
    });
  });
  setTimeout(() => {
    console.info({places}, {markerCount});
  }, 60000); // just in case, if places is updated, as it is not stored in realtime

  // change color of map markers based on the alphabetical first letter of the marker title (org name)
  const styleEl = document.createElement("style");
  // Append <style> element to <head>
  document.head.appendChild(styleEl);
  // Grab style element's sheet
  const styleSheet = styleEl.sheet;
  let deg = 0;
  alphabet.forEach((letter, index) => {
    if (index % 2 === 0) deg += 40; // hue shift 40 every 3rd letter of the alphabet, to spread letters among CSS hue as evenly as possible
    // styleSheet.insertRule(`img.leaflet-marker-icon[title^=${letter}] { filter: hue-rotate(${deg}deg); } `, 0);
  });
  const disclaimer = document.createElement("div");
  disclaimer.className = "leaflet-bottom leaflet-left disclaimer";
  disclaimer.innerHTML = "*note: locations on map are approximate";
  document.querySelector("#map")?.appendChild(disclaimer);
</script>
</body>
</html>
